---
title: "TS Assignment 8"
author: "&copy; Skye Zhang 2020. All rights reserved."
date: "June 01, 2020"
output: 
  pdf_document: 
    fig_height: 4
    fig_width: 6
    latex_engine: xelatex
header-includes:
  - \usepackage{fontspec}
  - \setmainfont{IBM Plex Sans}
---

# 1. Introduction

This assignment is dependent on completion of previous assignment. Objective of this project is to forecast CME seat prices using CME trading volume. Please note that this data is highly proprietary and confidential. Students registered for this class have been given permission to use the data ONLY for academic purpose and WITHOUT any dissemination.

Now that you have a monthly time series of CME seat prices, the file ```Contracts_Volume.csv``` contains the monthly trading volume for different CME products. Each row has the first date of the following month (the trade volume is for the month), the commodity indicator for CME, the short description of the commodity, whether it is Future (F) or Option (O), the electronic trading volume and the total trading volume. The floor trading volume is the difference between the total volume and the electronic volume.

*The attached file:* ```Contracts_Classification.csv``` *associates each CME commodity with a seat class.*

Note that owning a CME seat gives a trader advantage for floor trading. In contrast, owning a CME seat does not have any advantage for electronic trading. Since electronic trading constitutes market participants trading directly with other participants via CME's network connections and order matching engine.

There are three classes of seats CME, IMM, and IOM which confer the rights to trade different sets of commodities traded. CME seat owners can trade everything, IMM seat owners are allowed to trade all futures and options except agricultural products, and IOM seat owners are allowed to trade future and options only in index products and all other CME options.

To find the volume, for example index products, add both the futures and options volume for the same index product for a month.

Your task is to use the trading volume information to forecast the CME monthly seat price for 2013.  It is recommended to do exploratory data analysis to find initial data relationships such as correlations. For example, the total trade volume for all CME products might be a good predictor for CME seat class, but not for the others. You may have to choose and select which commodities have influence on the IMM and IOM seat prices.

The tasks are outlined below.

# 2. Task A

Use the following algorithms:

1. Linear regression (seat price is independent, volume(s) dependent)
2. Linear regression with ARMA errors (use arima with xreg)
3. Holt Winters
4. ARIMA
5. Seasonal ARIMA (SARIMA) - here seasonality is monthly
6. Fractional ARIMA (ARFIMA) - check applicability first using the ACF
7. ARMA and GARCH combination - use the fGarch R library and garchFit()

Note that you have to implement each of the above algorithms for each of the 3 classes of seats: CME, IMM, IOM. 

## Import libraries.

```{r, warning = FALSE, message = FALSE}
library(xts)
library(zoo)
library(TSA)
library(dplyr)
library(FinTS)
library(TSPred)
library(ggplot2)
library(fGarch)
library(imputeTS)
library(forecast)
library(kableExtra)
```

## Data preparation from Assignment 7.

```{r}
cme <- read.csv('/Users/tiavas/Dropbox/MSCA/Time\ Series/Week8/cmeS.csv')
imm <- read.csv('/Users/tiavas/Dropbox/MSCA/Time\ Series/Week8/immS.csv') 
iom <- read.csv('/Users/tiavas/Dropbox/MSCA/Time\ Series/Week8/iomS.csv')

CME <- xts(x=cme$price, order.by= as.Date(cme$DateOfSale, "%m/%d/%Y")) 
IMM <- xts(x=imm$price, order.by= as.Date(imm$DateOfSale, "%m/%d/%Y")) 
IOM <- xts(x=iom$price, order.by= as.Date(iom$DateOfSale, "%m/%d/%Y")) 

td <- as.yearmon(seq(as.Date("2001-01-01"), as.Date("2013-12-01"), by = "month"))

cme.monthly.m <- apply.monthly(CME, mean) 
imm.monthly.m <- apply.monthly(IMM, mean) 
iom.monthly.m <- apply.monthly(IOM, mean)

index(cme.monthly.m)<-as.yearmon(index(cme.monthly.m))
index(imm.monthly.m)<-as.yearmon(index(imm.monthly.m))
index(iom.monthly.m)<-as.yearmon(index(iom.monthly.m))

cme.monthly.withna <- merge(cme.monthly.m, td, all = TRUE, fill = NA) 
imm.monthly.withna <- merge(imm.monthly.m, td, all = TRUE, fill = NA) 
iom.monthly.withna <- merge(iom.monthly.m, td, all = TRUE, fill = NA)

cme.clean <- na_kalman(cme.monthly.withna,model = "auto.arima",smooth = TRUE)
imm.clean <- na_kalman(imm.monthly.withna,model = "auto.arima",smooth = TRUE)
iom.clean <- na_kalman(iom.monthly.withna,model = "auto.arima",smooth = TRUE)

seat_prices <-  merge(cme.clean, imm.clean, iom.clean)
colnames(seat_prices) = c("CME", "IMM", "IOM")
```

## Load the attached data and calculate the essential values
```{r}
contracts_volumn <- read.csv(
  '/Users/tiavas/Dropbox/MSCA/Time\ Series/Week8/Contracts_Volume.csv')
contracts_classification <- read.csv(
  '/Users/tiavas/Dropbox/MSCA/Time\ Series/Week8/Contracts_Classification.csv')
```
 
```{r}
#Calculate Floor volumn 
contracts_volumn$Floor.Volumn <-
  contracts_volumn$Total.Volume-as.numeric(contracts_volumn$Electronic.Volum) 

#Translate electronic volumn to numbers.
contracts_volumn$Electronic.Volum <- as.numeric(contracts_volumn$Electronic.Volum) 

#Translate date to date format.
contracts_volumn$Date <- as.Date(contracts_volumn$Date, format = "%m/%d/%Y") 

#Set the volumn time period match with the pricing time period. 
contracts_volumn<-subset(contracts_volumn,Date >="2001-01-01" & Date <"2014-01-01") 
```
 
## CME volumes.

```{r}
cme.code <- unique(
  contracts_classification[contracts_classification$Division == 'CME',]$Commodity.Code)
cme.contracts_volumn<-
  contracts_volumn[contracts_volumn$Commodity.Indicator %in% cme.code,]

cme.agg.volumn <- aggregate(cbind(Electronic.Volume, Total.Volume, Floor.Volumn)~Date, 
                            data=cme.contracts_volumn, sum)
cme.agg.volumn$Seat.Price <- seat_prices$CME
```
 
### Train-test split and plot the train set.
```{r}
cme.training <- subset(cme.agg.volumn, Date <"2013-01-01")
cme.holdout <- subset(cme.agg.volumn,Date >="2013-01-01") 
```

### Plot the electronic and the total volume for CME.

```{r}
plot(cme.agg.volumn$Date,cme.agg.volumn$Electronic.Volume, main = "CME Volumes",
     xlab = "Year", ylab = "CME Electronic Volume", type = "l", col = "#DE7A22")
```

```{r}
plot(cme.agg.volumn$Date,cme.agg.volumn$Total.Volume, main = "CME Volumes",
     xlab = "Year", ylab = "CME Total Volume", type = "l", col = "#20948B")
```

### i-1. Linear Regression, regress seat price on volumes.
```{r}
cme.m1 <- lm(Seat.Price ~ Electronic.Volume + Total.Volume, data=cme.training) 
summary(cme.m1)
```

### i-2. Linear Regression, keep the significant variables only.
```{r}
cme.m2 <- lm(Seat.Price ~ Electronic.Volume, data=cme.training)
checkresiduals(cme.m2)
```

The residuals do not follow a normal distribution and are autocorrelated. Therefore, an ARMA model is called for eliminating the autocorrelations.

### ii. Linear Regression with ARMA Errors.
```{r}
cme.m3<- auto.arima(cme.training$Seat.Price, xreg = 
                      as.matrix(cme.training[,c(2,3)]), allowdrift = FALSE) 
summary(cme.m3)
```

```{r}
checkresiduals(cme.m3)
```

The residuals are not autocorrelated and are somewhat independent. However, the residuals do not follow a normal distribution.

### iii. Holt Winters Method

```{r, warning = FALSE}
cme.m4 <- HoltWinters(ts(cme.training$Seat.Price,start = c(2001, 1), frequency = 12))
summary(cme.m4)
checkresiduals(cme.m4)
```

Checking the residuals could provide a sense of model performance. However, it does not make sense to conduct statistical tests on the residuals of Holt Winter models.

### iv.ARIMA
```{r}
cme.m5 <- auto.arima(cme.training$Seat.Price, allowdrift = FALSE, stepwise=FALSE) 
summary(cme.m5)
checkresiduals(cme.m5)
```

The residuals are independent, but there seem to be conditional heteroscedasticity in the residuals so one should conduct an LM test for the ARCH effect and then model the variance process by GARCH models. Intuitively, the residuals have a t-distribution, so the GARCH model should be specified accordingly.

### v.Seasonal ARIMA (SARIMA). Duration is a month.

```{r}
cme.m6 <- auto.arima(ts(cme.training$Seat.Price,frequency = 12),allowdrift = FALSE) 
summary(cme.m6)
checkresiduals(cme.m6)
```

A seasonal ARIMA does not really help.

### vi. ARFIMA (Long memory models)

```{r}
Acf(cme.training$Seat.Price)
```

**Based on the ACF figures of the regressions, I reckon that ARFIMA could be plausible models.**

```{r, warning=FALSE}
cme.m7 <-arfima(ts(cme.training$Seat.Price))
summary(cme.m7)
checkresiduals(cme.m7)
```

### vii. ARMA and GARCH Combination 

#### The Seat Price is not stationary (see the ACF plot and the ARIMA model), so I calculate the log return.

```{r}
cme.training.xts <- xts(cme.training$Seat.Price,
                        order.by = as.Date(cme.training$Date,"% m/%d/%Y")) 
cme.training.logreturn <- diff(log(cme.training.xts))[-1] 
auto.arima(cme.training.logreturn)
```

#### Test the ARCH effect using the LM-test. The null hypothesis is that there's no ARCH effects in the data.

```{r}
ArchTest(cme.training.logreturn)
```

The p-value is $0.4954 > 0.05$, so the null hypothesis cannot be rejected. Hence, there is no ARCH effects in the data. I should not run the GARCH models. However, it is required by the assignment.

#### Configure the GARCH model.

```{r, warning=FALSE}
cme.m8 <-garchFit(~arma(0,0)+garch(1,1),
                  data = cme.training.logreturn, cond.dist="std", trace=FALSE) 
summary(cme.m8)
```

In fact, among all coefficients, only the $\beta$ is significant.

### Make predictions and combine the results.
```{r}
cme.pred <- cbind(as.vector(predict(cme.m2,cme.holdout)), 
                  as.vector(predict(cme.m3,n.ahead=12,newxreg=cme.holdout[,c(2,3)])$pred),
                  predict(cme.m4, n.ahead=12), 
                  as.vector(forecast(cme.m5,h=12)$mean),
                  as.vector(forecast(cme.m6,h=12)$mean), 
                  as.vector(forecast(cme.m7,h=12)$mean), 
                  as.matrix(replicate(12,tail(cme.training.xts,1))*
                              exp(predict(cme.m8,n.ahead=12)$meanForecast)) )

cme.pred <- data.frame(cme.pred) %>% setNames(c('Regression', 
                                                'LR_eARMA', 
                                                'Holt Winters',
                                                'ARIMA',
                                                'SARIMA',
                                                'ARFIMA',
                                                'GARCH'))

kable(cme.pred)
```

## IMM volumes.

The models for IMM are same as CME, so I'll skip the explanations.

```{r}
imm.code <- unique(
  contracts_classification[contracts_classification$Division == 'IMM',]$Commodity.Code)
imm.contracts_volumn <- contracts_volumn[
  contracts_volumn$Commodity.Indicator %in% imm.code,]

imm.agg.volumn <- aggregate(cbind(Electronic.Volume, Total.Volume, Floor.Volumn)~Date,
                            data=imm.contracts_volumn, sum)
imm.agg.volumn$Seat.Price <- seat_prices$IMM

imm.training <- subset(imm.agg.volumn, Date <"2013-01-01") 
imm.holdout <- subset(imm.agg.volumn,Date >="2013-01-01")

plot(imm.agg.volumn$Date,imm.agg.volumn$Electronic.Volume, 
     main = "IMM Volumes",
     xlab = "Year", 
     ylab = "Electronic Volume",
     type = "l", col = "#6AB187")
```
```{r}
plot(imm.agg.volumn$Date,imm.agg.volumn$Total.Volume, 
     main = "IMM Volumes",
     xlab = "Year", ylab = "Total Volume",
     type = "l", col = "#444C5C")
```

### i. Linear Regression, regress seat price on volumes.
```{r}
imm.m1 <- lm(Seat.Price ~ Electronic.Volume + Total.Volume, data=imm.training)
summary(imm.m1)
checkresiduals(imm.m1)
```

### ii. Linear Regression with ARMA Errors.
```{r}
imm.m3<- auto.arima(imm.training$Seat.Price, 
                    xreg = as.matrix(imm.training[,c(2,3)]), allowdrift = FALSE) 
summary(imm.m3)
```

### iii. Holt Winter
```{r}
imm.m4<- HoltWinters(ts(imm.training$Seat.Price,start = c(2001, 1), frequency = 12)) 
summary(imm.m4)
```

### iv. ARIMA
```{r}
imm.m5 <- auto.arima(imm.training$Seat.Price, allowdrift = FALSE, stepwise=FALSE) 
summary(imm.m5)
checkresiduals(imm.m5)
```

### v. SARIMA
```{r}
imm.m6 <- auto.arima(ts(imm.training$Seat.Price,frequency = 12),allowdrift = FALSE) 
summary(imm.m6)
checkresiduals(imm.m6)
```

### vi. ARFIMA.

```{r}
Acf(imm.training$Seat.Price)
```

Long memory models are plausible.

```{r}
imm.m7 <-arfima(ts(imm.training$Seat.Price))
summary(imm.m7)
```

### vii. GARCH

```{r}
imm.training.xts <- xts(imm.training$Seat.Price, 
                        order.by = as.Date(imm.training$Date,"% m/%d/%Y")) 
imm.training.logreturn <- diff(log(imm.training.xts))[-1]
auto.arima(imm.training.logreturn)
```

```{r}
imm.m8 <-garchFit(~arma(0,2) + garch(1,1), 
                  data = imm.training.logreturn, 
                  cond.dist="std", trace=FALSE)
summary(imm.m8)
```

### Make predictions and combine the results.
```{r}
imm.pred <- cbind(as.vector(predict(imm.m1, imm.holdout)), 
                  as.vector(predict(imm.m3,n.ahead=12,newxreg=imm.holdout[,c(2,3)])$pred),
                  predict(imm.m4, n.ahead=12), 
                  as.vector(forecast(imm.m5,h=12)$mean),
                  as.vector(forecast(imm.m6,h=12)$mean), 
                  as.vector(forecast(imm.m7,h=12)$mean), 
                  as.matrix(replicate(12,tail(imm.training.xts,1))*
                              exp(predict(imm.m8,n.ahead=12)$meanForecast)) )

imm.pred <- data.frame(imm.pred) %>% setNames(c('Regression', 
                                                'LR_eARMA', 
                                                'Holt Winters',
                                                'ARIMA',
                                                'SARIMA',
                                                'ARFIMA',
                                                'GARCH'))

kable(imm.pred)
```

## IOM Volume.

```{r}
iom.code <- unique(
  contracts_classification[contracts_classification$Division == 'IOM',]$Commodity.Code)
iom.contracts_volumn <- contracts_volumn[
  contracts_volumn$Commodity.Indicator %in% iom.code,]

iom.agg.volumn <- aggregate(cbind(Electronic.Volume, Total.Volume, Floor.Volumn)~Date,
                            data=iom.contracts_volumn, sum)
iom.agg.volumn$Seat.Price <- seat_prices$IOM

iom.training <- subset(iom.agg.volumn, Date <"2013-01-01") 
iom.holdout <- subset(iom.agg.volumn,Date >="2013-01-01")

plot(iom.agg.volumn$Date,iom.agg.volumn$Electronic.Volume, 
     main = "IOM Volumes",
     xlab = "Year", 
     ylab = "Electronic Volume",
     type = "l", col = "#F4CC70")
```

```{r}
plot(iom.agg.volumn$Date,iom.agg.volumn$Total.Volume, 
     main = "IOM Volumes",
     xlab = "Year", 
     ylab = "Total Volume",
     type = "l", col = "#CE5A57")
```

### i. Linear Regression, regress seat price on volumes.
```{r}
iom.m1 <- lm(Seat.Price ~ Electronic.Volume + Total.Volume, data=iom.training)
summary(iom.m1)
checkresiduals(iom.m1)
```

### ii. Linear Regression with ARMA Errors.
```{r}
iom.m3<- auto.arima(iom.training$Seat.Price, 
                    xreg = as.matrix(iom.training[,c(2,3)]), allowdrift = FALSE) 
summary(iom.m3)
```

### iii. Holt Winter
```{r}
iom.m4<- HoltWinters(ts(iom.training$Seat.Price,start = c(2001, 1), frequency = 12)) 
summary(iom.m4)
```

### iv. ARIMA
```{r}
iom.m5 <- auto.arima(iom.training$Seat.Price, allowdrift = FALSE, stepwise=FALSE) 
summary(iom.m5)
checkresiduals(iom.m5)
```

### v. SARIMA
```{r}
iom.m6 <- auto.arima(ts(iom.training$Seat.Price,frequency = 12),allowdrift = FALSE) 
summary(iom.m6)
checkresiduals(iom.m6)
```

### vi. ARFIMA.

```{r}
Acf(iom.training$Seat.Price)
```

Long memory models are plausible.

```{r}
iom.m7 <-arfima(ts(iom.training$Seat.Price))
summary(iom.m7)
```

### vii. GARCH

```{r}
iom.training.xts <- xts(iom.training$Seat.Price, 
                        order.by = as.Date(iom.training$Date,"% m/%d/%Y")) 
iom.training.logreturn <- diff(log(iom.training.xts))[-1]
auto.arima(iom.training.logreturn)
```

```{r}
iom.m8 <-garchFit(~arma(0,1) + garch(1,1), 
                  data = iom.training.logreturn, cond.dist="std", trace=FALSE)
summary(iom.m8)
```

There is no ARCH effect nor GARCH effect. Why are we fitting GARCH models.

### Make predictions and combine the results.
```{r}
iom.pred <- cbind(as.vector(predict(iom.m1, iom.holdout)), 
                  as.vector(predict(iom.m3,n.ahead=12,newxreg=iom.holdout[,c(2,3)])$pred),
                  predict(iom.m4, n.ahead=12), 
                  as.vector(forecast(iom.m5,h=12)$mean),
                  as.vector(forecast(iom.m6,h=12)$mean), 
                  as.vector(forecast(iom.m7,h=12)$mean), 
                  as.matrix(replicate(12,tail(iom.training.xts,1))*
                              exp(predict(iom.m8,n.ahead=12)$meanForecast)) )

iom.pred <- data.frame(iom.pred) %>% setNames(c('Regression', 
                                                'LR_eARMA', 
                                                'Holt Winters',
                                                'ARIMA',
                                                'SARIMA',
                                                'ARFIMA',
                                                'GARCH'))

kable(iom.pred)
```

# 3. Task B

Since you already have the seat prices for the 2013, evaluate each algorithm from Task A using sMAPE. Which one do you recommend to forecast monthly prices for each of the seat classes?

```{r}
smape <- rbind(mapply(sMAPE, cme.pred, data.frame(cme.holdout$Seat.Price)), 
               mapply(sMAPE, imm.pred, data.frame(imm.holdout$Seat.Price)), 
               mapply(sMAPE, iom.pred, data.frame(iom.holdout$Seat.Price))
               )
smape <- data.frame(smape) 
row.names(smape) <- c('CME', 'IMM', 'IOM') 
kable(smape, caption = "sMAPE Comparasions")
```

```{r}
smape.lowest<-data.frame() 
for (i in 1:nrow(smape)){
  smape.lowest[i,1]<-colnames(smape[which.min(smape[i,])])
  smape.lowest[i,2]<-min(smape[i,]) 
} 
row.names(smape.lowest) <- c('CME', 'IMM', 'IOM')
colnames(smape.lowest) <-c('Best Model', 'SMAPE')
kable(smape.lowest)
```

**The best performed model for CME is ARFIMA. The best model for IMM is Holt Winters. The best model for IOM is GARCH.**

